diff -Naurw ./drivers/media/i2c/ap1302.c ../kernel-source/drivers/media/i2c/ap1302.c
--- ./drivers/media/i2c/ap1302.c	1970-01-01 01:00:00.000000000 +0100
+++ ../kernel-source/drivers/media/i2c/ap1302.c	2020-08-15 10:46:49.790400696 +0200
@@ -0,0 +1,2185 @@
+/*
+ * Copyright (C) 2020 Arrow Electronics
+ * Author: Botond Kardos
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/sched/signal.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/firmware.h>
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+
+#define AP1302_DBG_CONSOLE_OUTPUT   0
+#define AP1302_TRACE_LOG            0
+
+#if AP1302_DBG_CONSOLE_OUTPUT
+ #define DBG_PRINT  printk
+#else
+ #define DBG_PRINT
+#endif
+
+#define AP1302_FW_TEST    "ap1302/test_pattern.bin"
+#define AP1302_FW_NORMAL  "ap1302/on_ar1337_cdaf_dw9718.290520_01.bin"
+
+#define AP1302_EXP_TIME_DEFAULT         4000
+#define AP1302_EXP_TIME_MAX             100000
+
+/* min/typical/max system clock (xclk) frequencies */
+#define AP1302_XCLK_MIN 24000000
+#define AP1302_XCLK_MAX 24000000
+
+#define AP1302_TMP_BUF_SIZE     8196
+
+#define AP1302_I2C_LINE_MAX     256
+
+#define AP1302_DEFAULT_SLAVE_ID 0x3d
+
+#define AP1302_STREAM_AFTER     ( 48 * 1024 )
+
+#define AP1302_REG_CHIP_ID		        0x0000
+#define AP1302_REG_FRAME_CNT	        0x0002
+#define AP1302_REG_MFR    		        0x0004
+
+#define AP1302_REG_OUT0_WIDTH           0x0084
+#define AP1302_REG_OUT0_HEIGHT          0x0086
+#define AP1302_REG_OUT0_FMT             0x0088
+#define AP1302_REG_OUT1_WIDTH           0x0092
+#define AP1302_REG_OUT1_HEIGHT          0x0094
+#define AP1302_REG_OUT1_FMT             0x0096
+#define AP1302_REG_SENSOR_WIDTH         0x00c4
+#define AP1302_REG_SENSOR_HEIGHT        0x00c6
+
+#define AP1302_REG_CON_BUF_0_1          0x0a2c
+
+#define AP1302_REG_UPTIME_SEC           0x0E34
+#define AP1302_REG_UPTIME_SEC_FRAC      0x0E38
+
+#define AP1302_REG_ORIENTATION  		0x100c
+
+#define AP1302_REG_PREVIEW_MAX_FPS 		0x2020
+
+#define AP1302_REG_AE_CTRL				0x5002
+#define AP1302_REG_AE_MANUAL_EXP_TIME	0x500c
+
+#define AP1302_REG_BOOTDATA_STAGE       0x6002
+#define AP1302_REG_SENSOR_SELECT		0x600c
+#define AP1302_REG_SYS_START            0x601a
+#define AP1302_REG_BOOTDATA_CHSUM       0x6134
+
+#define AP1302_REG_PREVIEW_W	        0x2000
+#define AP1302_REG_PREVIEW_H	        0x2002
+
+#define AP1302_REG_BOOTDATA_START       0x8000
+#define AP1302_REG_BOOTDATA_WRAP        0xa000
+
+#if AP1302_TMP_BUF_SIZE < ( AP1302_REG_BOOTDATA_WRAP - AP1302_REG_BOOTDATA_START + 2 )
+ #error "AP1302_TMP_BUF_SIZE too small"
+#endif
+
+#define AP1302_REG_ADVANCED_BASE        0xf038
+
+#define AP1302_SYS_START_PLL_LOCK       0x8000
+
+#define AP1302_CHIP_VERSION     0x0265
+#define AP1302_CHIP_MFR         0x0006
+
+
+enum ap1302_mode_id {
+	AP1302_MODE_320_240 = 0,
+	AP1302_MODE_VGA_640_480,
+	AP1302_MODE_1024_576,
+	AP1302_MODE_720P_1280_720,
+	AP1302_MODE_1080P_1920_1080,
+/*	AP1302_MODE_2560_1440, */
+/*	AP1302_MODE_2160P_3840_2160, */
+	AP1302_MODE_4160_3120,
+	AP1302_NUM_MODES,
+};
+
+enum ap1302_frame_rate {
+	AP1302_3_FPS = 0,
+	AP1302_10_FPS,
+	AP1302_15_FPS,
+	AP1302_25_FPS,
+	AP1302_NUM_FRAMERATES,
+};
+
+struct ap1302_pixfmt {
+	u32 code;
+	u32 colorspace;
+};
+
+static const struct ap1302_pixfmt ap1302_formats[] = {
+	{ MEDIA_BUS_FMT_RGB565_2X8_LE, V4L2_COLORSPACE_SRGB, },
+	{ MEDIA_BUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_SRGB, },
+};
+
+/*
+ * FIXME: remove this when a subdev API becomes available
+ * to set the MIPI CSI-2 virtual channel.
+ */
+static unsigned int virtual_channel;
+module_param(virtual_channel, uint, 0444);
+MODULE_PARM_DESC(virtual_channel,
+		 "MIPI CSI-2 virtual channel (0..3), default 0");
+
+static const int ap1302_framerates[] = {
+	[AP1302_3_FPS] = 3,
+	[AP1302_10_FPS] = 10,
+	[AP1302_15_FPS] = 15,
+	[AP1302_25_FPS] = 25,
+};
+
+/* regulator supplies */
+static const char * const ap1302_supply_name[] = {
+	"DOVDD", /* Digital I/O (1.8V) supply */
+};
+
+#define AP1302_NUM_SUPPLIES ARRAY_SIZE(ap1302_supply_name)
+
+struct reg_value {
+	u16 reg_addr;
+	u8 val;
+	u8 mask;
+	u32 delay_ms;
+};
+
+struct ap1302_reg_value {
+	const int len;
+	const u8 data[ 6 ];
+};
+
+struct ap1302_mode_info {
+	enum ap1302_mode_id id;
+	u32 hact;
+	u32 vact;
+	struct ap1302_reg_value *p_mode;
+	int mode_len;
+	int max_fps;
+};
+
+struct ap1302_ctrls {
+	struct v4l2_ctrl_handler handler;
+	struct v4l2_ctrl *test_pattern;
+	int test_value;
+	struct v4l2_ctrl *hflip;
+	int hflip_value;
+	struct v4l2_ctrl *vflip;
+	int vflip_value;
+	struct v4l2_ctrl *link_freq;
+	struct v4l2_ctrl *auto_exp;
+	struct v4l2_ctrl *exposure;
+};
+
+struct ap1302_dev {
+	struct i2c_client *i2c_client;
+	struct v4l2_subdev sd;
+	struct media_pad pad;
+	struct v4l2_fwnode_endpoint ep; /* the parsed DT endpoint info */
+	struct clk *xclk; /* system clock to AP1302 */
+	u32 xclk_freq;
+
+	struct regulator_bulk_data supplies[AP1302_NUM_SUPPLIES];
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwdn_gpio;
+	struct gpio_desc *i2csel_gpio;
+	struct gpio_desc *pwr_cam_gpio;
+	bool   upside_down;
+
+	/* lock to protect all members below */
+	struct mutex lock;
+
+	int power_count;
+	int power_state;
+
+	struct v4l2_mbus_framefmt fmt;
+	bool pending_fmt_change;
+
+	const struct ap1302_mode_info *current_mode;
+	const struct ap1302_mode_info *last_mode;
+	enum ap1302_frame_rate current_fr;
+	struct v4l2_fract frame_interval;
+
+	struct ap1302_ctrls ctrls;
+
+	u32 prev_sysclk, prev_hts;
+	u32 ae_low, ae_high, ae_target;
+
+	u8 tmp_buf[ AP1302_TMP_BUF_SIZE ];
+#if AP1302_DBG_CONSOLE_OUTPUT && AP1302_TRACE_LOG
+	u8 dbg_buf1[ 512 ];
+	u8 dbg_buf2[ 512 ];
+#endif
+	int last_end;
+	bool pending_mode_change;
+	bool streaming;
+	bool fw_down;
+	const struct firmware *fw_sensor;
+	const struct firmware *fw_test;
+};
+
+static inline struct ap1302_dev *to_ap1302_dev(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct ap1302_dev, sd);
+}
+
+static inline struct v4l2_subdev *ctrl_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ap1302_dev,
+			     ctrls.handler)->sd;
+}
+
+static struct ap1302_reg_value ap1302_fmt_RGB565[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x12,  0x00, 0x41 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+	{ 4, { 0x20, 0x16,  0x1E, 0x22 }, },
+};
+
+static struct ap1302_reg_value ap1302_fmt_YUV422[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x12,  0x00, 0x50 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+	{ 4, { 0x20, 0x16,  0x1E, 0x1E }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_320_240[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x01, 0x40 }, },
+	{ 4, { 0x20, 0x02,  0x00, 0xF0 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_640_480[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x02, 0x80 }, },
+	{ 4, { 0x20, 0x02,  0x01, 0xE0 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_1024_576[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x04, 0x00 }, },
+	{ 4, { 0x20, 0x02,  0x02, 0x40 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_1280_720[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x05, 0x00 }, },
+	{ 4, { 0x20, 0x02,  0x02, 0xd0 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_1920_1080[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x07, 0x80 }, },
+	{ 4, { 0x20, 0x02,  0x04, 0x38 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+#if 0
+static struct ap1302_reg_value ap1302_mode_2560_1440[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x0a, 0x00 }, },
+	{ 4, { 0x20, 0x02,  0x05, 0xa0 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static struct ap1302_reg_value ap1302_mode_3840_2160[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x0f, 0x00 }, },
+	{ 4, { 0x20, 0x02,  0x08, 0x70 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+#endif
+
+static struct ap1302_reg_value ap1302_mode_4160_3120[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x10, 0x40 }, },
+	{ 4, { 0x20, 0x02,  0x0c, 0x30 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+};
+
+static const struct ap1302_mode_info
+ap1302_mode_data[AP1302_NUM_MODES] = {
+	{AP1302_MODE_320_240, 320, 240, ap1302_mode_320_240, ARRAY_SIZE(ap1302_mode_320_240), 25},
+	{AP1302_MODE_VGA_640_480, 640, 480, ap1302_mode_640_480, ARRAY_SIZE(ap1302_mode_640_480), 25},
+	{AP1302_MODE_1024_576, 1024, 576, ap1302_mode_1024_576, ARRAY_SIZE(ap1302_mode_1024_576), 25},
+	{AP1302_MODE_720P_1280_720, 1280, 720, ap1302_mode_1280_720, ARRAY_SIZE(ap1302_mode_1280_720), 15},
+	{AP1302_MODE_1080P_1920_1080, 1920, 1080, ap1302_mode_1920_1080, ARRAY_SIZE(ap1302_mode_1920_1080), 15},
+/*	{AP1302_MODE_2560_1440, 2560, 1440, ap1302_mode_2560_1440, ARRAY_SIZE(ap1302_mode_2560_1440)}, */
+/*	{AP1302_MODE_2160P_3840_2160, 3840, 2160, ap1302_mode_3840_2160, ARRAY_SIZE(ap1302_mode_3840_2160)}, */
+	{AP1302_MODE_4160_3120, 4160, 3120, ap1302_mode_4160_3120, ARRAY_SIZE(ap1302_mode_4160_3120), 3},
+};
+
+
+static int ap1302_write_reg(struct ap1302_dev *sensor, u16 reg, u8 val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	buf[2] = val;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = buf;
+	msg.len = sizeof(buf);
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x, val=%x\n",
+			__func__, reg, val);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static void hex_dump( u8 *p_buf, int len, int start )
+{
+	char line[ 128 ];
+	char word[ 8 ];
+	int cnt;
+
+	while( len > 0 ) {
+		sprintf( line, KERN_ALERT "**** %04x: ", start );
+		for( cnt = 0 ; cnt < 16 ; cnt++ ) {
+			if ( !len )
+				break;
+			len--;
+			start++;
+			sprintf( word, " %02x", *p_buf++ );
+			strcat( line, word );
+		}
+		strcat( line, "\n" );
+		printk( line );
+	}
+} /* hex_dump */
+
+
+static int ap1302_write_buf(struct ap1302_dev *sensor, u8 *p_buf, int len)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg;
+	int ret, reg_addr;
+
+    /* printk( KERN_ALERT "**** %s %i   len: %i\n", __func__, (int )__LINE__, len );
+	   hex_dump( p_buf, 16, 0 ); */
+
+	reg_addr = ( (u32 )p_buf[ 0 ] << 8 ) + (u32 )p_buf[ 1 ];
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.buf = p_buf;
+	msg.len = len;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: addr=%x\n", __func__, reg_addr);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ap1302_read_buf(struct ap1302_dev *sensor, u16 reg, u8 *p_buf, int len)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 reg_addr[2];
+	int ret;
+
+	reg_addr[0] = reg >> 8;
+	reg_addr[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = reg_addr;
+	msg[0].len = sizeof(reg_addr);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = p_buf;
+	msg[1].len = len;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n", __func__, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ap1302_read_reg(struct ap1302_dev *sensor, u16 reg, u8 *val)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].buf = buf;
+	msg[0].len = sizeof(buf);
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = 1;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: error: reg=%x\n",
+			__func__, reg);
+		return ret;
+	}
+
+	*val = buf[0];
+	return 0;
+}
+
+static int ap1302_read_reg16(struct ap1302_dev *sensor, u16 reg, u16 *val)
+{
+	int ret;
+
+	ret = ap1302_read_buf(sensor, reg, (u8 *)val, 2 );
+	if ( !ret )
+		*val = be16_to_cpu( *val );
+
+	return ret;
+}
+
+static int ap1302_write_reg16(struct ap1302_dev *sensor, u16 reg, u16 val)
+{
+	u8 buf[ 4 ];
+
+	buf[ 0 ] = reg >> 8;
+	buf[ 1 ] = reg & 0xff;
+	buf[ 2 ] = val >> 8;
+	buf[ 3 ] = val & 0xff;
+
+	return ap1302_write_buf( sensor, buf, sizeof( buf ) );
+}
+
+static int ap1302_write_reg32(struct ap1302_dev *sensor, u16 reg, u32 val)
+{
+	u8 buf[ 6 ];
+
+	buf[ 0 ] = reg >> 8;
+	buf[ 1 ] = reg & 0xff;
+	buf[ 2 ] = val >> 24;
+	buf[ 3 ] = ( val >> 16 ) & 0xff;
+	buf[ 4 ] = ( val >> 8 ) & 0xff;
+	buf[ 5 ] = val & 0xff;
+
+	return ap1302_write_buf( sensor, buf, sizeof( buf ) );
+}
+
+static int ap1302_mod_reg(struct ap1302_dev *sensor, u16 reg,
+			  u8 mask, u8 val)
+{
+	u8 readval;
+	int ret;
+
+	ret = ap1302_read_reg(sensor, reg, &readval);
+	if (ret)
+		return ret;
+
+	readval &= ~mask;
+	val &= mask;
+	val |= readval;
+
+	return ap1302_write_reg(sensor, reg, val);
+}
+
+static int ap1302_mod_reg16(struct ap1302_dev *sensor,
+							u16 reg, u16 mask, u16 val)
+{
+	int ret;
+	u16 readval;
+
+	ret = ap1302_read_reg16(sensor, reg, &readval );
+	if ( !ret ) {
+		readval &= ~mask;
+		readval |= ( val & mask );
+		ret = ap1302_write_reg16( sensor, reg, readval );
+	}
+
+	return ret;
+}
+
+
+static const struct ap1302_mode_info *
+ap1302_find_mode(struct ap1302_dev *sensor, enum ap1302_frame_rate fr,
+		 int width, int height, bool nearest)
+{
+	const struct ap1302_mode_info *mode;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   width: %i   height: %i\n", __func__, (int )__LINE__, width, height );
+	mode = v4l2_find_nearest_size(ap1302_mode_data,
+				      ARRAY_SIZE(ap1302_mode_data),
+				      hact, vact,
+				      width, height);
+
+	if (!mode ||
+	    (!nearest && (mode->hact != width || mode->vact != height)))
+		return NULL;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   h: %i   v: %i\n", __func__, (int )__LINE__, mode->hact, mode->vact );
+	return mode;
+}
+
+
+static void ap1302_power(struct ap1302_dev *sensor, bool enable)
+{
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	gpiod_set_value_cansleep(sensor->pwdn_gpio, enable ? 0 : 1);
+}
+
+static void ap1302_reset(struct ap1302_dev *sensor)
+{
+	if (!sensor->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	/* camera power cycle */
+	ap1302_power(sensor, false);
+	usleep_range(5000, 10000);
+	ap1302_power(sensor, true);
+	usleep_range(5000, 10000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 1);
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(sensor->reset_gpio, 0);
+	usleep_range(20000, 25000);
+}
+
+static int ap1302_set_power_on(struct ap1302_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	ret = clk_prepare_enable(sensor->xclk);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable clock\n",
+			__func__);
+		return ret;
+	}
+
+	ret = regulator_bulk_enable(AP1302_NUM_SUPPLIES,
+				    sensor->supplies);
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to enable regulators\n",
+			__func__);
+		goto xclk_off;
+	}
+
+	ap1302_reset(sensor);
+	ap1302_power(sensor, true);
+	sensor->power_state = 1;
+
+	return 0;
+
+xclk_off:
+	clk_disable_unprepare(sensor->xclk);
+	return ret;
+}
+
+static void ap1302_set_power_off(struct ap1302_dev *sensor)
+{
+	sensor->power_state = 0;
+	ap1302_power(sensor, false);
+	regulator_bulk_disable(AP1302_NUM_SUPPLIES, sensor->supplies);
+	clk_disable_unprepare(sensor->xclk);
+}
+
+
+static const s64 link_freq_menu_items[] = {
+	160000000,
+};
+
+
+static const char * const test_pattern_menu[] = {
+	"Disabled",
+	"Color Bars",
+	"Color Bars Fade to Grey",
+};
+
+
+static int ap1302_set_ctrl_test_pattern(struct ap1302_dev *sensor, int value)
+{
+	int ret;
+	u16 val;
+
+	switch ( value ) {
+		case 0:
+			val = 0x0211;
+			break;
+
+		case 1:
+			val = 0x0310;
+			break;
+
+		default:
+			val = 0x0410;
+			break;
+	}
+
+	ret = ap1302_write_reg16( sensor, AP1302_REG_SENSOR_SELECT, val );
+	if ( !ret )
+		sensor->ctrls.test_value = value;
+
+	return ret;
+}
+
+static int ap1302_set_ctrl_hflip(struct ap1302_dev *sensor, int value)
+{
+	int ret;
+
+	value = !!value;
+	ret = ap1302_mod_reg16( sensor, AP1302_REG_ORIENTATION, 1 << 0, value );
+	if ( !ret )
+		sensor->ctrls.hflip_value = value;
+
+	return ret;
+}
+
+static int ap1302_set_ctrl_vflip(struct ap1302_dev *sensor, int value)
+{
+	int ret;
+
+	value = !!value;
+	ret = ap1302_mod_reg16( sensor, AP1302_REG_ORIENTATION, 1 << 1, value << 1 );
+	if ( !ret )
+		sensor->ctrls.vflip_value = value;
+
+	return ret;
+}
+
+static int ap1302_set_ctrl_auto_exp(struct ap1302_dev *sensor, int value)
+{
+	int ret;
+	u16 reg_val;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   value: %i\n", __func__, (int )__LINE__, value );
+
+	if ( value == V4L2_EXPOSURE_AUTO )
+		reg_val = 0x0c;
+	else
+		reg_val = 0x09;
+
+	ret = ap1302_mod_reg16( sensor, AP1302_REG_AE_CTRL, 0x0f, reg_val );
+	return ret;
+}
+
+static int ap1302_set_ctrl_exp(struct ap1302_dev *sensor, int value)
+{
+	int ret;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   value: %i\n", __func__, (int )__LINE__, value );
+
+	ret = ap1302_write_reg32( sensor, AP1302_REG_AE_MANUAL_EXP_TIME, value );
+	return ret;
+}
+
+static int ap1302_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	DBG_PRINT( KERN_ALERT "**** %s %i   index: %i\n", __func__, (int )__LINE__, fse->index );
+
+	if (fse->pad != 0)
+		return -EINVAL;
+	if (fse->index >= AP1302_NUM_MODES)
+		return -EINVAL;
+
+	fse->min_width =
+		ap1302_mode_data[fse->index].hact;
+	fse->max_width = fse->min_width;
+	fse->min_height =
+		ap1302_mode_data[fse->index].vact;
+	fse->max_height = fse->min_height;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   w: %i   h: %i\n", __func__, (int )__LINE__, fse->max_width, fse->max_height );
+
+	return 0;
+}
+
+static int ap1302_try_frame_interval(struct ap1302_dev *sensor,
+				     struct v4l2_fract *fi,
+				     u32 width, u32 height)
+{
+	const struct ap1302_mode_info *mode;
+	enum ap1302_frame_rate rate = AP1302_3_FPS;
+	int minfps, maxfps, best_fps, fps;
+	int i;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   w: %i   h: %i   num: %i   denom: %i\n",
+			   __func__, (int )__LINE__, width, height, fi->numerator, fi->denominator );
+
+	minfps = ap1302_framerates[0];
+	for ( i = AP1302_NUM_MODES - 1 ; i >= 0 ; i-- ) {
+		maxfps = ap1302_mode_data[ i ].max_fps;
+		if ( ( width >= ap1302_mode_data[ i ].hact ) ||
+			 ( height >= ap1302_mode_data[ i ].vact ) )
+			break;
+	}
+
+	if (fi->numerator == 0) {
+		fi->denominator = maxfps;
+		fi->numerator = 1;
+		for ( i = 0 ; i < AP1302_NUM_FRAMERATES ; i++ ) {
+			if ( maxfps == ap1302_framerates[ i ] ) {
+				rate = i;
+				break;
+			}
+		}
+		goto find_mode;
+	}
+
+	fps = clamp_val(DIV_ROUND_CLOSEST(fi->denominator, fi->numerator),
+			minfps, maxfps);
+
+	best_fps = minfps;
+	for (i = 0; i < ARRAY_SIZE(ap1302_framerates); i++) {
+		int curr_fps = ap1302_framerates[i];
+
+		if (abs(curr_fps - fps) < abs(best_fps - fps)) {
+			best_fps = curr_fps;
+			rate = i;
+		}
+	}
+
+	fi->numerator = 1;
+	fi->denominator = best_fps;
+
+find_mode:
+	mode = ap1302_find_mode(sensor, rate, width, height, false);
+	return mode ? rate : -EINVAL;
+}
+
+static int ap1302_enum_frame_interval(
+	struct v4l2_subdev *sd,
+	struct v4l2_subdev_pad_config *cfg,
+	struct v4l2_subdev_frame_interval_enum *fie)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	struct v4l2_fract tpf;
+	int ret;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	if (fie->pad != 0)
+		return -EINVAL;
+	if (fie->index >= AP1302_NUM_FRAMERATES)
+		return -EINVAL;
+
+	tpf.numerator = 1;
+	tpf.denominator = ap1302_framerates[fie->index];
+
+	ret = ap1302_try_frame_interval(sensor, &tpf,
+					fie->width, fie->height);
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+	if (ret < 0)
+		return -EINVAL;
+
+	fie->interval = tpf;
+	return 0;
+};
+
+static int ap1302_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	return -EINVAL;
+}
+
+static int ap1302_set_fps( struct ap1302_dev *sensor );
+
+static int ap1302_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ctrl_to_sd(ctrl);
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	int ret;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	/* v4l2_ctrl_lock() locks our own mutex */
+
+	if ( !sensor->power_state )
+		return -EINVAL;
+
+	switch (ctrl->id) {
+		case V4L2_CID_TEST_PATTERN:
+			ret = ap1302_set_ctrl_test_pattern(sensor, ctrl->val);
+			break;
+
+		case V4L2_CID_HFLIP:
+			ret = ap1302_set_ctrl_hflip(sensor, ctrl->val);
+			break;
+
+		case V4L2_CID_VFLIP:
+			ret = ap1302_set_ctrl_vflip(sensor, ctrl->val);
+			break;
+
+		case V4L2_CID_EXPOSURE_AUTO:
+			ret = ap1302_set_ctrl_auto_exp(sensor, ctrl->val);
+			break;
+
+		case V4L2_CID_EXPOSURE:
+			ret = ap1302_set_ctrl_exp(sensor, ctrl->val);
+			break;
+
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	if( !ret && sensor->streaming )
+		/* ap1302_set_fps() will fix MIPI color order */
+		ret = ap1302_set_fps( sensor );
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ap1302_ctrl_ops = {
+	.g_volatile_ctrl = ap1302_g_volatile_ctrl,
+	.s_ctrl = ap1302_s_ctrl,
+};
+
+static int ap1302_init_controls(struct ap1302_dev *sensor)
+{
+	const struct v4l2_ctrl_ops *ops = &ap1302_ctrl_ops;
+	struct ap1302_ctrls *ctrls = &sensor->ctrls;
+	struct v4l2_ctrl_handler *hdl = &ctrls->handler;
+	int ret;
+
+	v4l2_ctrl_handler_init(hdl, 2);
+
+	/* we can use our own mutex for the ctrl lock */
+	hdl->lock = &sensor->lock;
+
+	ctrls->test_pattern =
+		v4l2_ctrl_new_std_menu_items(hdl, ops, V4L2_CID_TEST_PATTERN,
+					     ARRAY_SIZE(test_pattern_menu) - 1,
+					     0, 0, test_pattern_menu);
+
+	ctrls->hflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_HFLIP,
+					 0, 1, 1, 0);
+	ctrls->vflip = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_VFLIP,
+					 0, 1, 1, 0);
+
+	ctrls->link_freq = v4l2_ctrl_new_int_menu(hdl, ops, V4L2_CID_LINK_FREQ,
+						  0, 0, link_freq_menu_items);
+	if (ctrls->link_freq)
+		ctrls->link_freq->flags |= V4L2_CTRL_FLAG_READ_ONLY;
+
+	/* Auto/manual exposure */
+	ctrls->auto_exp = v4l2_ctrl_new_std_menu(hdl, ops, V4L2_CID_EXPOSURE_AUTO,
+											 V4L2_EXPOSURE_MANUAL, 0,
+											 V4L2_EXPOSURE_MANUAL);
+	ctrls->exposure = v4l2_ctrl_new_std(hdl, ops, V4L2_CID_EXPOSURE,
+					    0, AP1302_EXP_TIME_MAX, 1, AP1302_EXP_TIME_DEFAULT);
+
+	if (hdl->error) {
+		ret = hdl->error;
+		goto free_ctrls;
+	}
+
+	sensor->sd.ctrl_handler = hdl;
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(hdl);
+	return ret;
+}
+
+static int ap1302_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	if (code->pad != 0)
+		return -EINVAL;
+	if (code->index >= ARRAY_SIZE(ap1302_formats))
+		return -EINVAL;
+
+	code->code = ap1302_formats[code->index].code;
+	return 0;
+}
+
+static int ap1302_s_power(struct v4l2_subdev *sd, int on)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	int ret = 0;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i   on: %i\n", __func__, (int )__LINE__, on );
+
+	mutex_lock(&sensor->lock);
+
+	if ( on )
+		ret = ap1302_set_power_on( sensor );
+	else {
+		sensor->streaming = false;
+		sensor->fw_down = false;
+		ap1302_set_power_off( sensor );
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+static int ap1302_g_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	mutex_lock(&sensor->lock);
+	fi->interval = sensor->frame_interval;
+	mutex_unlock(&sensor->lock);
+
+	return 0;
+}
+
+static int ap1302_s_frame_interval(struct v4l2_subdev *sd,
+				   struct v4l2_subdev_frame_interval *fi)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	const struct ap1302_mode_info *mode;
+	int frame_rate, ret = 0;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i   num: %i   denum: %i\n", __func__, (int )__LINE__, fi->interval.numerator, fi->interval.denominator );
+
+	if (fi->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	mode = sensor->current_mode;
+
+	frame_rate = ap1302_try_frame_interval(sensor, &fi->interval,
+					       mode->hact, mode->vact);
+    DBG_PRINT( KERN_ALERT "**** %s %i   frame_rate: %i\n", __func__, (int )__LINE__, frame_rate );
+
+	if (frame_rate < 0) {
+		/* Always return a valid frame interval value */
+		fi->interval = sensor->frame_interval;
+		goto out;
+	}
+
+	mode = ap1302_find_mode(sensor, frame_rate, mode->hact,
+				mode->vact, true);
+    DBG_PRINT( KERN_ALERT "**** %s %i   mode: 0x%08x\n", __func__, (int )__LINE__, (int )mode );
+
+	if (!mode) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (mode != sensor->current_mode ||
+	    frame_rate != sensor->current_fr) {
+		sensor->current_fr = frame_rate;
+		sensor->frame_interval = fi->interval;
+		sensor->current_mode = mode;
+		sensor->pending_mode_change = true;
+	}
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+
+/* format of binary firmware files */
+struct ap1302_fw_data {
+	u32 chksum;
+	u32 pll_init_size;
+	u32 total_size;
+	u32 dummy;
+};
+
+static int ap1302_fw_loop(struct ap1302_dev *sensor, struct ap1302_fw_data *p_fw_data );
+static int ap1302_set_format( struct ap1302_dev *sensor );
+static int ap1302_set_mode( struct ap1302_dev *sensor );
+
+static int ap1302_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	int ret = 0;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i   enable: %i\n", __func__, (int )__LINE__, enable );
+
+	mutex_lock(&sensor->lock);
+
+	if ( enable && sensor->ep.bus_type == V4L2_MBUS_CSI2 ) {
+		if ( !sensor->streaming && !sensor->fw_down ) {
+			ret = ap1302_fw_loop( sensor, (struct ap1302_fw_data *)sensor->fw_sensor->data );
+			DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+		}
+
+		if (!ret)
+			sensor->streaming = true;
+	}
+
+	if ( !enable )
+		sensor->streaming = false;
+	else {
+		if ( !ret )
+			ret = ap1302_set_format( sensor );
+
+		if ( !ret )
+			ret = ap1302_set_mode( sensor );
+
+		if ( !ret )
+			ret = ap1302_set_ctrl_test_pattern( sensor, sensor->ctrls.test_value );
+
+		if ( !ret )
+			ret = ap1302_mod_reg16( sensor, AP1302_REG_ORIENTATION, 0x03,
+									( sensor->ctrls.vflip_value << 1 ) | sensor->ctrls.hflip_value );
+
+		if ( !ret )
+			ret = ap1302_set_ctrl_auto_exp(sensor, sensor->ctrls.auto_exp->val);
+
+		if ( !ret )
+			ret = ap1302_set_ctrl_exp(sensor, sensor->ctrls.exposure->val);
+
+		if ( !ret )
+			/* ap1302_set_fps() also fixes MIPI color order */
+			ret = ap1302_set_fps( sensor );
+	}
+
+	mutex_unlock(&sensor->lock);
+	return ret;
+} /* ap1302_s_stream */
+
+static int ap1302_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	struct v4l2_mbus_framefmt *fmt;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+		fmt = v4l2_subdev_get_try_format(&sensor->sd, cfg,
+						 format->pad);
+	}
+	else
+		fmt = &sensor->fmt;
+
+	format->format = *fmt;
+
+	mutex_unlock(&sensor->lock);
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+	return 0;
+}
+
+static int ap1302_try_fmt_internal(struct v4l2_subdev *sd,
+				   struct v4l2_mbus_framefmt *fmt,
+				   enum ap1302_frame_rate fr,
+				   const struct ap1302_mode_info **new_mode)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	const struct ap1302_mode_info *mode;
+	int i;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	mode = ap1302_find_mode(sensor, fr, fmt->width, fmt->height, true);
+	if (!mode)
+		return -EINVAL;
+	fmt->width = mode->hact;
+	fmt->height = mode->vact;
+
+	if (new_mode)
+		*new_mode = mode;
+
+	for (i = 0; i < ARRAY_SIZE(ap1302_formats); i++)
+		if (ap1302_formats[i].code == fmt->code)
+			break;
+	if (i >= ARRAY_SIZE(ap1302_formats))
+		i = 0;
+
+	fmt->code = ap1302_formats[i].code;
+	fmt->colorspace = ap1302_formats[i].colorspace;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+
+    DBG_PRINT( KERN_ALERT "**** %s %i   code:0x%x\n", __func__, (int )__LINE__, fmt->code );
+	return 0;
+}
+
+static int ap1302_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+	const struct ap1302_mode_info *new_mode;
+	struct v4l2_mbus_framefmt *mbus_fmt = &format->format;
+	struct v4l2_mbus_framefmt *fmt;
+	int ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	if (format->pad != 0)
+		return -EINVAL;
+
+	mutex_lock(&sensor->lock);
+
+	if (sensor->streaming) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	ret = ap1302_try_fmt_internal(sd, mbus_fmt,
+				      sensor->current_fr, &new_mode);
+	if (ret)
+		goto out;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		fmt = v4l2_subdev_get_try_format(sd, cfg, 0);
+	else
+		fmt = &sensor->fmt;
+
+	*fmt = *mbus_fmt;
+
+	if (new_mode != sensor->current_mode) {
+		sensor->current_mode = new_mode;
+		sensor->pending_mode_change = true;
+	}
+	if (mbus_fmt->code != sensor->fmt.code)
+		sensor->pending_fmt_change = true;
+
+out:
+	mutex_unlock(&sensor->lock);
+	return ret;
+}
+
+
+static const struct v4l2_subdev_core_ops ap1302_core_ops = {
+	.s_power = ap1302_s_power,
+	.log_status = v4l2_ctrl_subdev_log_status,
+	.subscribe_event = v4l2_ctrl_subdev_subscribe_event,
+	.unsubscribe_event = v4l2_event_subdev_unsubscribe,
+};
+
+static const struct v4l2_subdev_video_ops ap1302_video_ops = {
+	.g_frame_interval = ap1302_g_frame_interval,
+	.s_frame_interval = ap1302_s_frame_interval,
+	.s_stream = ap1302_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ap1302_pad_ops = {
+	.enum_mbus_code = ap1302_enum_mbus_code,
+	.get_fmt = ap1302_get_fmt,
+	.set_fmt = ap1302_set_fmt,
+	.enum_frame_size = ap1302_enum_frame_size,
+	.enum_frame_interval = ap1302_enum_frame_interval,
+};
+
+static const struct v4l2_subdev_ops ap1302_subdev_ops = {
+	.core = &ap1302_core_ops,
+	.video = &ap1302_video_ops,
+	.pad = &ap1302_pad_ops,
+};
+
+static int ap1302_get_regulators(struct ap1302_dev *sensor)
+{
+	int i;
+
+	for (i = 0; i < AP1302_NUM_SUPPLIES; i++)
+		sensor->supplies[i].supply = ap1302_supply_name[i];
+
+	return devm_regulator_bulk_get(&sensor->i2c_client->dev,
+				       AP1302_NUM_SUPPLIES,
+				       sensor->supplies);
+}
+
+
+static int ap1302_check_chip_id(struct ap1302_dev *sensor)
+{
+	struct i2c_client *client = sensor->i2c_client;
+	int ret = 0;
+	u32 adv_addr;
+	u16 val;
+
+	ret = ap1302_set_power_on(sensor);
+	if (ret)
+		return ret;
+
+	ret = ap1302_read_reg16(sensor, AP1302_REG_CHIP_ID, &val );
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		goto power_off;
+	}
+
+    DBG_PRINT( KERN_ALERT "**** %s %i  CHIP ID: 0x%04x\n", __func__, (int )__LINE__, (int )val );
+
+	if ( val != AP1302_CHIP_VERSION ) {
+		ret = -EINVAL;
+		goto power_off;
+	}
+
+	ret = ap1302_read_buf(sensor, AP1302_REG_ADVANCED_BASE, (u8 *)&adv_addr, sizeof( adv_addr ) );
+	if (ret) {
+		dev_err(&client->dev, "%s: failed to read chip identifier\n",
+			__func__);
+		goto power_off;
+	}
+
+	adv_addr = be32_to_cpu( adv_addr );
+    DBG_PRINT( KERN_ALERT "**** %s %i  ADVANCED_BASE: 0x%08x\n", __func__, (int )__LINE__, (int )adv_addr );
+
+	return 0;
+
+power_off:
+	ap1302_set_power_off(sensor);
+	return ret;
+}
+
+
+struct read_reg {
+	const u16 reg;
+	const int len;
+};
+
+static struct ap1302_reg_value ap1302_fw_stage[ ] = {
+	{ 4, { 0x60, 0x02,  0x00, 0x01 } },
+	{ 4, { 0x60, 0x02,  0x00, 0x02 } },
+	{ 4, { 0x60, 0x02,  0xff, 0xff } },
+};
+
+static struct ap1302_reg_value ap1302_fw_pll_320M[ ] = {
+	{ 6, { 0x60, 0x24,  0x00, 0x30, 0x00, 0x00 } },
+	{ 6, { 0x60, 0x2C,  0x00, 0x1A, 0x01, 0x00 } },
+	{ 6, { 0x60, 0x38,  0x00, 0x14, 0x01, 0x00 } },
+	{ 6, { 0x20, 0x50,  0x00, 0x01, 0x00, 0x08 } },
+	{ 6, { 0x20, 0x54,  0x00, 0x01, 0x00, 0x09 } },
+	{ 6, { 0x20, 0x58,  0x00, 0x03, 0x00, 0x02 } },
+	{ 6, { 0x20, 0x5C,  0x00, 0x03, 0x00, 0x09 } },
+	{ 6, { 0x20, 0x64,  0x00, 0x03, 0x00, 0x04 } },
+	{ 6, { 0x20, 0x68,  0x00, 0x01, 0x00, 0x09 } },
+	{ 6, { 0x20, 0x6C,  0x00, 0x00, 0x00, 0x3E } },
+	{ 6, { 0x20, 0x70,  0x00, 0x01, 0x00, 0x26 } },
+	{ 6, { 0x20, 0x74,  0x00, 0x01, 0x00, 0xFF } },
+};
+
+static struct ap1302_reg_value ap1302_fw_defaults[ ] = {
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x30,  0x00, 0x12 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x20, 0x00,  0x02, 0x80 }, },
+	{ 4, { 0x20, 0x02,  0x01, 0xE0 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+	{ 4, { 0x20, 0x20,  0x0F, 0x00 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x01 }, },
+	{ 4, { 0x11, 0x84,  0x00, 0x0B }, },
+	{ 4, { 0x20, 0x16,  0x1E, 0x1E }, },
+	{ 4, { 0x20, 0x18,  0x00, 0x1E }, },
+};
+
+static struct ap1302_reg_value ap1302_ae_values[ ] = {
+	{ 6, { 0x50, 0x00,  0x1f, 0x31, 0x02, 0x2c }, },
+	{ 6, { 0x50, 0x04,  0x08, 0x00, 0x01, 0x00 }, },
+	{ 6, { 0x50, 0x08,  0x00, 0x64, 0x00, 0x00 }, },
+	{ 6, { 0x50, 0x0c,  0x00, 0x00, 0x27, 0x10 }, },
+	{ 6, { 0x50, 0x10,  0xf8, 0x80, 0x0c, 0x00 }, },
+	{ 6, { 0x50, 0x14,  0x00, 0x00, 0x00, 0x00 }, },
+	{ 6, { 0x50, 0x18,  0xfd, 0xcd, 0x00, 0x80 }, },
+	{ 6, { 0x50, 0x1c,  0x0e, 0x70, 0x00, 0x80 }, },
+	{ 6, { 0x50, 0x20,  0x10, 0x00, 0x00, 0x4c }, },
+	{ 6, { 0x50, 0x24,  0x00, 0x05, 0x00, 0x00 }, },
+	{ 6, { 0x50, 0x28,  0x00, 0x04, 0x00, 0x64 }, },
+	{ 6, { 0x50, 0x2c,  0x00, 0x64, 0x04, 0x00 }, },
+	{ 6, { 0x50, 0x30,  0x00, 0x80, 0x40, 0x00 }, },
+	{ 6, { 0x50, 0x34,  0x0c, 0x00, 0x10, 0x00 }, },
+	{ 6, { 0x50, 0x38,  0x10, 0x00, 0x30, 0x00 }, },
+	{ 6, { 0x50, 0x3c,  0x30, 0x00, 0x00, 0x02 }, },
+}; /* ap1302_ae_values */
+
+static struct ap1302_reg_value ap1302_fix_mipi_rgb[ ] = {
+	{ 6, { 0xf0, 0x38,  0x00, 0x73, 0x00, 0x00 } },
+	{ 6, { 0xe0, 0x00,  0x00, 0x00, 0x00, 0x04 } },
+};
+
+static struct ap1302_reg_value ap1302_fix_mipi_yuv[ ] = {
+	{ 6, { 0xf0, 0x38,  0x00, 0x73, 0x00, 0x00 } },
+	{ 6, { 0xe0, 0x00,  0x00, 0xb1, 0x40, 0x0e } },
+};
+
+static const struct read_reg ap1302_read_regs[] = {
+	{ AP1302_REG_OUT0_WIDTH, 2 }, { AP1302_REG_OUT0_HEIGHT, 2 }, { AP1302_REG_OUT0_FMT, 2 },
+};
+
+
+static int ap1302_write_regs( struct ap1302_dev *sensor, struct ap1302_reg_value *p_regs, int len )
+{
+	int ret;
+
+	ret = 0;
+	while ( !ret && len > 0 ) {
+		memcpy( sensor->tmp_buf, p_regs->data, p_regs->len );
+		ret = ap1302_write_buf(sensor, sensor->tmp_buf, p_regs->len );
+		p_regs++;
+		len--;
+	}
+	return ret;
+}
+
+static int ap1302_fw_change_state(struct ap1302_dev *sensor, int stage, bool wait_new_stage )
+{
+	int ret, cnt;
+	struct ap1302_reg_value *p_stage;
+	u16 val;
+
+	switch( stage ) {
+		case 1:
+			p_stage = &ap1302_fw_stage[ 0 ];
+			break;
+
+		case 2:
+			p_stage = &ap1302_fw_stage[ 1 ];
+			break;
+
+		default:
+			p_stage = &ap1302_fw_stage[ 2 ];
+			break;
+	}
+
+	ret = ap1302_write_regs( sensor, p_stage, 1 );
+    DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	if ( wait_new_stage ) {
+		/* wait for new BOOTDATA_STAGE  */
+		for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
+			msleep( 2 );
+			ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_STAGE, &val );
+			if ( ret || ( val == stage ) )
+				break;
+		}
+
+		DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   cnt:%i   stage: 0x%04x\n", __func__, (int )__LINE__, ret, cnt, val );
+
+		if ( !ret && ( cnt == 10 ) )
+			ret = -EINVAL;
+	}
+
+	return ret;
+};
+
+static int ap1302_trace_log(struct ap1302_dev *sensor, int line )
+{
+#if AP1302_DBG_CONSOLE_OUTPUT && AP1302_TRACE_LOG
+	int ret;
+	int cnt, idx, idx2, len;
+	u16 stage;
+
+	ret = ap1302_read_buf( sensor, AP1302_REG_CON_BUF_0_1, sensor->dbg_buf2, 512 );
+	if (!ret ) {
+		len = 512;
+		idx = sensor->last_end;
+		while ( len >= 0 ) {
+			if ( --idx < 0 )
+				idx = 511;
+			if ( sensor->dbg_buf2[ idx ] != sensor->dbg_buf1[ idx ] )
+				break;
+			len--;
+		}
+
+		printk( KERN_ALERT "**** %s %i   last_end: %i   idx: %i\n", __func__, line, sensor->last_end, idx );
+
+		if ( len > 0 ) {
+			memcpy( sensor->dbg_buf1, sensor->dbg_buf2, 512 );
+			memset( sensor->dbg_buf2, 0, 512 );
+			idx2 = sensor->last_end;
+			for ( cnt = 0 ; ( cnt < 511 ) && ( idx2 != idx ) ; cnt++ ) {
+				sensor->dbg_buf2[ cnt ] = sensor->dbg_buf1[ idx2 ];
+				if ( ++idx2 > 511 )
+					idx2 = 0;
+			}
+
+			/* hex_dump( sensor->dbg_buf2, cnt, 0 ); */
+			ap1302_read_reg16( sensor, AP1302_REG_BOOTDATA_STAGE, & stage );
+			printk( KERN_ALERT "**** %s %i   stage: 0x%04x   msg: %s\n", __func__, line, (int )stage, sensor->dbg_buf2 );
+
+			if ( ++idx > 511 )
+				idx = 0;
+
+			sensor->last_end = idx;
+		}
+	}
+
+	return ret;
+
+#else
+	return 0;
+#endif
+};
+
+static int ap1302_fw_loop(struct ap1302_dev *sensor, struct ap1302_fw_data *p_fw_data )
+{
+	u8 *p_buf;
+	int ret, len, chunk, offs, cnt;
+	u16 addr, val;
+
+	len = p_fw_data->total_size;
+	addr = AP1302_REG_BOOTDATA_START;
+	p_buf = (u8 *)&p_fw_data[ 1 ];
+	ret = 0;
+	offs = 0;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* let's download 1st chunk */
+	sensor->tmp_buf[ 0 ] = addr >> 8;
+	sensor->tmp_buf[ 1 ] = addr & 0xff;
+	memcpy( sensor->tmp_buf + 2, p_buf, p_fw_data->pll_init_size );
+	ret = ap1302_write_buf( sensor, sensor->tmp_buf, p_fw_data->pll_init_size + 2 );
+    DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	if ( ret )
+		return ret;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* change stage */
+	ret = ap1302_fw_change_state( sensor, 1, true );
+
+	if ( ret )
+		return ret;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* set PLL */
+	ret = ap1302_write_regs( sensor, ap1302_fw_pll_320M, ARRAY_SIZE( ap1302_fw_pll_320M ) );
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* change stage */
+	if ( !ret )
+		ret = ap1302_fw_change_state( sensor, 2, true );
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* see if PLL locks */
+	for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
+		msleep( 2 );
+		ret = ap1302_read_reg16(sensor, AP1302_REG_SYS_START, &val );
+		if ( ret || ( val & AP1302_SYS_START_PLL_LOCK ) )
+			break;
+	}
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   cnt:%i\n", __func__, (int )__LINE__, ret, cnt );
+
+	if ( !ret && ( cnt == 10 ) )
+		ret = -EINVAL;
+
+	if ( ret )
+		return ret;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* download the rest */
+	offs += p_fw_data->pll_init_size;
+	p_buf += p_fw_data->pll_init_size;
+	addr += p_fw_data->pll_init_size;
+
+	while ( !ret && ( offs < len ) ) {
+		sensor->tmp_buf[ 0 ] = addr >> 8;
+		sensor->tmp_buf[ 1 ] = addr & 0xff;
+
+		chunk = AP1302_REG_BOOTDATA_WRAP - addr;
+		if ( chunk > ( len - offs ) )
+			chunk = len - offs;
+
+		memcpy( sensor->tmp_buf + 2, p_buf, chunk );
+		ret = ap1302_write_buf( sensor, sensor->tmp_buf, chunk + 2 );
+
+#if AP1302_DBG_CONSOLE_OUTPUT && AP1302_TRACE_LOG
+		if ( !ret ) {
+			ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_STAGE, &val );
+			printk( KERN_ALERT "**** %s %i   ret: %i   addr: 0x%04x   stage: 0x%04x\n", __func__, (int )__LINE__, ret, addr, val );
+		}
+#endif
+
+		(void )ap1302_trace_log( sensor, __LINE__ );
+
+		addr += chunk;
+		if ( addr >= AP1302_REG_BOOTDATA_WRAP )
+			addr = AP1302_REG_BOOTDATA_START;
+		p_buf += chunk;
+
+		/* interrupt the loop at position AP1302_STREAM_AFTER */
+		offs += chunk;
+		if ( offs >= AP1302_STREAM_AFTER )
+			break;
+	} /* while */
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   offs: 0x%04x\n", __func__, (int )__LINE__, ret, offs );
+
+	/* hack here to make test pattern bootdata download work */
+	if ( !ret && ( offs < len ) ) {
+		msleep( 2 );
+		for ( cnt = 0 ; !ret && ( cnt < ARRAY_SIZE( ap1302_read_regs ) ) ; cnt++ ) {
+			ret = ap1302_read_buf(sensor, ap1302_read_regs[cnt].reg,
+								  sensor->tmp_buf, ap1302_read_regs[cnt].len );
+			msleep( 1 );
+		}
+	}
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* continue downloading the rest */
+	while ( !ret && ( offs < len ) ) {
+		sensor->tmp_buf[ 0 ] = addr >> 8;
+		sensor->tmp_buf[ 1 ] = addr & 0xff;
+
+		chunk = AP1302_REG_BOOTDATA_WRAP - addr;
+		if ( chunk > ( len - offs ) )
+			chunk = len - offs;
+
+		memcpy( sensor->tmp_buf + 2, p_buf, chunk );
+		ret = ap1302_write_buf( sensor, sensor->tmp_buf, chunk + 2 );
+
+#if AP1302_DBG_CONSOLE_OUTPUT && AP1302_TRACE_LOG
+		if ( !ret ) {
+			ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_STAGE, &val );
+			printk( KERN_ALERT "**** %s %i   ret: %i   addr: 0x%04x   stage: 0x%04x\n", __func__, (int )__LINE__, ret, addr, val );
+		}
+#endif
+
+		(void )ap1302_trace_log( sensor, __LINE__ );
+
+		addr += chunk;
+		if ( addr >= AP1302_REG_BOOTDATA_WRAP )
+			addr = AP1302_REG_BOOTDATA_START;
+		p_buf += chunk;
+		offs += chunk;
+	} /* while */
+
+	if ( ret )
+		return ret;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   offs: 0x%04x\n", __func__, (int )__LINE__, ret, offs );
+
+#if AP1302_DBG_CONSOLE_OUTPUT && AP1302_TRACE_LOG
+	/* wait for bootdata checksum to be calculated by downloaded FW */
+	for( cnt = 0 ; !ret && ( cnt < 100 ) ; cnt++ ) {
+		msleep( 2 );
+		ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_CHSUM, &val );
+		if ( !ret && ( ( val != 0 ) && ( val != p_fw_data->chksum ) ) )
+			ret = -EINVAL;
+
+		if( ret || ( val == p_fw_data->chksum ) )
+			break;
+	}
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	if ( ret )
+		return ret;
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   cnt:%i   val:0x%04x\n", __func__, (int )__LINE__, ret, cnt, val );
+	if ( !ret ) {
+		ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_STAGE, &val );
+		DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   stage: 0x%04x\n", __func__, (int )__LINE__, ret, val );
+	}
+#endif
+
+	/* change stage */
+	(void )ap1302_fw_change_state( sensor, 0xffff, true );
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* wait for bootdata checksum to be calculated by downloaded FW */
+	for( cnt = 0 ; !ret && ( cnt < 100 ) ; cnt++ ) {
+		msleep( 2 );
+		ret = ap1302_read_reg16(sensor, AP1302_REG_BOOTDATA_CHSUM, &val );
+		if ( !ret && ( ( val != 0 ) && ( val != p_fw_data->chksum ) ) )
+			ret = -EINVAL;
+
+		if( ret || ( val == p_fw_data->chksum ) )
+			break;
+	}
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   cnt:%i   val:0x%04x\n", __func__, (int )__LINE__, ret, cnt, val );
+
+	if ( !ret && ( cnt == 100 ) )
+		ret = -EINVAL;
+
+	if ( ret )
+		return ret;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	/* set defaults */
+	ret = ap1302_write_regs( sensor, ap1302_fw_defaults, ARRAY_SIZE( ap1302_fw_defaults ) );
+    DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+#if AP1302_DBG_CONSOLE_OUTPUT
+	for ( cnt = 0 ; !ret && ( cnt < 10 ) ; cnt++ ) {
+		(void )ap1302_trace_log( sensor, __LINE__ );
+
+		ret = ap1302_read_reg16(sensor, AP1302_REG_FRAME_CNT, &val );
+		printk( KERN_ALERT "**** %s %i   ret: %i   val: 0x%04x\n", __func__, (int )__LINE__, ret, val );
+		msleep( 200 );
+	}
+#endif
+
+	if ( !ret )
+		sensor->fw_down = true;
+
+	(void )ap1302_trace_log( sensor, __LINE__ );
+
+	return ret;
+} /* fw_loop */
+
+static int ap1302_set_format(struct ap1302_dev *sensor)
+{
+	int len, ret;
+	struct ap1302_reg_value *p_regs;
+
+	switch ( sensor->fmt.code )
+	{
+		case MEDIA_BUS_FMT_RGB565_2X8_LE:
+			p_regs = ap1302_fmt_RGB565;
+			len = ARRAY_SIZE( ap1302_fmt_RGB565 );
+			break;
+
+		case MEDIA_BUS_FMT_YUYV8_2X8:
+		default:
+			p_regs = ap1302_fmt_YUV422;
+			len = ARRAY_SIZE( ap1302_fmt_YUV422 );
+			break;
+	}
+
+	ret = ap1302_write_regs( sensor, p_regs, len );
+	DBG_PRINT( KERN_ALERT "**** %s %i   code: 0x%04x   ret: %i\n",
+			   __func__, (int )__LINE__, sensor->fmt.code, ret );
+
+	return ret;
+}
+
+static int ap1302_set_mode(struct ap1302_dev *sensor)
+{
+	int ret;
+
+	ret = ap1302_write_regs( sensor, ap1302_ae_values, ARRAY_SIZE( ap1302_ae_values ) );
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	if ( !ret )
+		ret = ap1302_set_ctrl_auto_exp( sensor, V4L2_EXPOSURE_MANUAL );
+
+	if ( !ret )
+		ret = ap1302_set_ctrl_exp( sensor, AP1302_EXP_TIME_DEFAULT );
+
+	if ( !ret ) {
+	ret = ap1302_write_regs( sensor, sensor->current_mode->p_mode, sensor->current_mode->mode_len );
+	DBG_PRINT( KERN_ALERT "**** %s %i   w: %i   h: %i   ret: %i\n",
+			   __func__, (int )__LINE__, sensor->current_mode->hact, sensor->current_mode->vact, ret );
+	}
+
+	return ret;
+}
+
+static int ap1302_set_fps( struct ap1302_dev *sensor )
+{
+	int ret, cnt, len;
+	struct ap1302_reg_value *p_regs;
+	u16 frame1, frame2;
+	u16 val;
+
+	cnt = 0;
+	val = ap1302_framerates[ sensor->current_fr ] << 8;
+    DBG_PRINT( KERN_ALERT "**** %s %i   val: 0x%04x\n", __func__, (int )__LINE__, (int )val );
+	ret = ap1302_write_reg16( sensor, AP1302_REG_PREVIEW_MAX_FPS, val );
+
+	if ( !ret )
+		ret = ap1302_read_reg16(sensor, AP1302_REG_FRAME_CNT, &val );
+
+	if ( !ret ) {
+		frame1 = val >> 8;
+
+		/* wait some frames 1st */
+		for ( cnt = 0 ; cnt < 50 ; cnt++ ) {
+			ret = ap1302_read_reg16(sensor, AP1302_REG_FRAME_CNT, &val );
+			if ( ret )
+				break;
+
+			frame2 = val >> 8;
+			if ( ( ( frame2 - frame1 ) & 0xff ) > 10 ) {
+				/* fix MIPI color order */
+
+				switch ( sensor->fmt.code )
+				{
+					case MEDIA_BUS_FMT_RGB565_2X8_LE:
+						p_regs = ap1302_fix_mipi_rgb;
+						len = ARRAY_SIZE( ap1302_fix_mipi_rgb );
+						break;
+
+					case MEDIA_BUS_FMT_YUYV8_2X8:
+					default:
+						p_regs = ap1302_fix_mipi_yuv;
+						len = ARRAY_SIZE( ap1302_fix_mipi_yuv );
+						break;
+				}
+
+
+				ret = ap1302_write_regs( sensor, p_regs, len );
+				break;      /* get out of the for() loop */
+			}
+
+			msleep( 100 );
+		}
+	}
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i   cnt: %i\n", __func__, (int )__LINE__, ret, cnt );
+	return ret;
+}
+
+static int ap1302_download_fw(struct ap1302_dev *sensor)
+{
+	int ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+	ret = 0;
+
+	ret = request_firmware(&sensor->fw_test, AP1302_FW_TEST, &sensor->i2c_client->dev);
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	if ( !ret && sensor->fw_test->data == NULL )
+		ret = -EINVAL;
+
+	if ( ret ) {
+		dev_err( &sensor->i2c_client->dev, "failed to download firmware\n" );
+		goto power_off;
+	}
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   size: %i\n", __func__, (int )__LINE__, sensor->fw_test->size );
+
+	ret = request_firmware(&sensor->fw_sensor, AP1302_FW_NORMAL, &sensor->i2c_client->dev);
+	DBG_PRINT( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+
+	if ( !ret && sensor->fw_sensor->data == NULL )
+		ret = -EINVAL;
+
+	if ( ret ) {
+		dev_err( &sensor->i2c_client->dev, "failed to download firmware\n" );
+		goto release_fw;
+	}
+
+	DBG_PRINT( KERN_ALERT "**** %s %i   size: %i\n", __func__, (int )__LINE__, sensor->fw_sensor->size );
+		return 0;
+
+release_fw:
+	if ( sensor->fw_test != NULL )
+		release_firmware( sensor->fw_test );
+	if ( sensor->fw_sensor != NULL )
+		release_firmware( sensor->fw_sensor );
+
+power_off:
+	/* ap1302_set_power_off(sensor); */
+	return ret;
+}
+
+
+static struct ap1302_dev *my_sensor = NULL;
+
+/**
+ * sysfs interface function handling ".../write_reg16"
+ */
+static ssize_t ap1302_sysfs_write16(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int addr, val, ret;
+	u8 reg_buf[4];
+
+	if ( ( my_sensor != NULL ) && ( sscanf( buf, "%x %x", &addr, &val ) == 2 ) ) {
+		mutex_lock(&my_sensor->lock);
+		reg_buf[0] = ( addr >> 8 ) & 0xff;
+		reg_buf[1] = addr & 0xff;
+		reg_buf[2] = ( val >> 8 ) & 0xff;
+		reg_buf[3] = val & 0xff;
+		ret = ap1302_write_buf( my_sensor, reg_buf, 4 );
+		printk( KERN_ALERT "**** %s %i   addr: 0x%04x   val: 0x%04x   ret: %i\n", __func__, (int )__LINE__, addr, val, ret );
+		mutex_unlock(&my_sensor->lock);
+	}
+
+	return count;
+}
+
+/**
+ * sysfs interface function handling ".../write_reg32"
+ */
+static ssize_t ap1302_sysfs_write32(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int addr, val, ret;
+	u8 reg_buf[6];
+
+	if ( ( my_sensor != NULL ) && ( sscanf( buf, "%x %x", &addr, &val ) == 2 ) ) {
+		mutex_lock(&my_sensor->lock);
+		reg_buf[0] = ( addr >> 8 ) & 0xff;
+		reg_buf[1] = addr & 0xff;
+		reg_buf[2] = ( val >> 24 ) & 0xff;
+		reg_buf[3] = ( val >> 16 ) & 0xff;
+		reg_buf[4] = ( val >> 8 ) & 0xff;
+		reg_buf[5] = val & 0xff;
+		ret = ap1302_write_buf( my_sensor, reg_buf, 6 );
+		hex_dump( &reg_buf[2], 4, addr );
+		mutex_unlock(&my_sensor->lock);
+	}
+
+	return count;
+}
+
+/**
+ * sysfs interface function handling ".../dump"
+ */
+static ssize_t ap1302_sysfs_dump(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int addr, len, ret;
+
+	if ( ( my_sensor != NULL ) && ( sscanf( buf, "%x %x", &addr, &len ) == 2 ) ) {
+		mutex_lock(&my_sensor->lock);
+		if ( len > AP1302_TMP_BUF_SIZE )
+			len = AP1302_TMP_BUF_SIZE;
+
+		ret = ap1302_read_buf(my_sensor, addr, my_sensor->tmp_buf, len );
+		if ( !ret )
+			hex_dump( my_sensor->tmp_buf, len, addr );
+
+		mutex_unlock(&my_sensor->lock);
+	}
+
+	return count;
+}
+
+
+static struct kobj_attribute ap1302_sysfs_attr_write16 = {
+	.attr = { .name = "write_reg16", .mode = VERIFY_OCTAL_PERMISSIONS(0220) },
+	.show = NULL,
+	.store = ap1302_sysfs_write16,
+};
+
+static struct kobj_attribute ap1302_sysfs_attr_write32 = {
+	.attr = { .name = "write_reg32", .mode = VERIFY_OCTAL_PERMISSIONS(0220) },
+	.show = NULL,
+	.store = ap1302_sysfs_write32,
+};
+
+static struct kobj_attribute ap1302_sysfs_attr_dump = {
+	.attr = { .name = "dump", .mode = VERIFY_OCTAL_PERMISSIONS(0220) },
+	.show = NULL,
+	.store = ap1302_sysfs_dump,
+};
+
+
+static int ap1302_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct fwnode_handle *endpoint;
+	struct ap1302_dev *sensor;
+	struct v4l2_mbus_framefmt *fmt;
+	char *path;
+	u32 rotation;
+	int ret;
+
+	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
+	if (!sensor)
+		return -ENOMEM;
+
+	sensor->i2c_client = client;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	/* get system clock (xclk) */
+	sensor->xclk = devm_clk_get(dev, "xclk");
+	if (IS_ERR(sensor->xclk)) {
+		dev_err(dev, "failed to get xclk\n");
+		return PTR_ERR(sensor->xclk);
+	}
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	sensor->xclk_freq = clk_get_rate(sensor->xclk);
+	if (sensor->xclk_freq < AP1302_XCLK_MIN ||
+	    sensor->xclk_freq > AP1302_XCLK_MAX) {
+		dev_err(dev, "xclk frequency out of range: %d Hz\n",
+			sensor->xclk_freq);
+		return -EINVAL;
+	}
+
+	/* request optional power down pin */
+	sensor->pwdn_gpio = devm_gpiod_get_optional(dev, "powerdown",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwdn_gpio))
+		DBG_PRINT( KERN_ALERT "**** %s %i  ERROR\n", __func__, (int )__LINE__ );
+
+	/* request optional reset pin */
+	sensor->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(sensor->reset_gpio))
+		DBG_PRINT( KERN_ALERT "**** %s %i  ERROR\n", __func__, (int )__LINE__ );
+
+	/* request optional I2C address select pin */
+	sensor->i2csel_gpio = devm_gpiod_get_optional(dev, "i2csel",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->i2csel_gpio))
+		DBG_PRINT( KERN_ALERT "**** %s %i  ERROR\n", __func__, (int )__LINE__ );
+	else
+		gpiod_set_value_cansleep(sensor->i2csel_gpio, 1);
+
+	/* request optional camera PWR pin */
+	sensor->pwr_cam_gpio = devm_gpiod_get_optional(dev, "pwrcam",
+						    GPIOD_OUT_HIGH);
+	if (IS_ERR(sensor->pwr_cam_gpio))
+		DBG_PRINT( KERN_ALERT "**** %s %i  ERROR\n", __func__, (int )__LINE__ );
+	else
+		gpiod_set_value_cansleep(sensor->pwr_cam_gpio, 1);
+
+	ret = ap1302_get_regulators(sensor);
+	if (ret)
+		return ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	mutex_init(&sensor->lock);
+
+	ret = ap1302_check_chip_id(sensor);
+	if (ret)
+		return ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	ret = ap1302_download_fw(sensor);
+	if (ret)
+		return ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	/*
+	 * default init sequence initialize sensor to
+	 * YUV422 VGA@15fps
+	 */
+	fmt = &sensor->fmt;
+	fmt->code = MEDIA_BUS_FMT_YUYV8_2X8;
+	fmt->colorspace = V4L2_COLORSPACE_SRGB;
+	fmt->ycbcr_enc = V4L2_MAP_YCBCR_ENC_DEFAULT(fmt->colorspace);
+	fmt->quantization = V4L2_QUANTIZATION_FULL_RANGE;
+	fmt->xfer_func = V4L2_MAP_XFER_FUNC_DEFAULT(fmt->colorspace);
+	fmt->width = 640;
+	fmt->height = 480;
+	fmt->field = V4L2_FIELD_NONE;
+	sensor->frame_interval.numerator = 1;
+	sensor->frame_interval.denominator = ap1302_framerates[AP1302_15_FPS];
+	sensor->current_fr = AP1302_15_FPS;
+
+	sensor->current_mode = &ap1302_mode_data[AP1302_MODE_VGA_640_480];
+	sensor->last_mode = sensor->current_mode;
+
+	sensor->ae_target = 52;
+
+	/* optional indication of physical rotation of sensor */
+	ret = fwnode_property_read_u32(dev_fwnode(&client->dev), "rotation",
+				       &rotation);
+	if (!ret) {
+		switch (rotation) {
+		case 180:
+			sensor->upside_down = true;
+			/* fall through */
+		case 0:
+			break;
+		default:
+			dev_warn(dev, "%u degrees rotation is not supported, ignoring...\n",
+				 rotation);
+		}
+	}
+
+	endpoint = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev),
+						  NULL);
+	if (!endpoint) {
+		dev_err(dev, "endpoint node not found\n");
+		return -EINVAL;
+	}
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	ret = v4l2_fwnode_endpoint_parse(endpoint, &sensor->ep);
+	fwnode_handle_put(endpoint);
+	if (ret) {
+		dev_err(dev, "Could not parse endpoint\n");
+		return ret;
+	}
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	v4l2_i2c_subdev_init(&sensor->sd, client, &ap1302_subdev_ops);
+
+	sensor->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			    V4L2_SUBDEV_FL_HAS_EVENTS;
+	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
+	sensor->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&sensor->sd.entity, 1, &sensor->pad);
+	if (ret)
+		return ret;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	mutex_init(&sensor->lock);
+
+	ret = ap1302_init_controls(sensor);
+	if (ret)
+		goto entity_cleanup;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	ret = v4l2_async_register_subdev(&sensor->sd);
+	if (ret)
+		goto free_ctrls;
+
+    DBG_PRINT( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+
+	my_sensor = sensor;
+	path = kobject_get_path(&dev->kobj, GFP_KERNEL);
+	if ( path != NULL )
+		ret = sysfs_create_file(&dev->kobj, &ap1302_sysfs_attr_write16.attr);
+	else {
+		DBG_PRINT( KERN_ALERT "**** %s %i   path: NULL\n", __func__, (int )__LINE__ );
+		ret = -EINVAL;
+	}
+
+	if ( !ret )
+		ret = sysfs_create_file(&dev->kobj, &ap1302_sysfs_attr_write32.attr);
+
+	if ( !ret )
+		ret = sysfs_create_file(&dev->kobj, &ap1302_sysfs_attr_dump.attr);
+
+	if ( !ret )
+		printk( KERN_ALERT "ap1302 sysfs path: /sys%s\n", path );
+
+	return 0;
+
+free_ctrls:
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+entity_cleanup:
+	mutex_destroy(&sensor->lock);
+	media_entity_cleanup(&sensor->sd.entity);
+	return ret;
+} /* ap1302_probe */
+
+
+static int ap1302_remove(struct i2c_client *client)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ap1302_dev *sensor = to_ap1302_dev(sd);
+
+	if ( sensor->fw_test != NULL )
+		release_firmware( sensor->fw_test );
+	if ( sensor->fw_sensor != NULL )
+		release_firmware( sensor->fw_sensor );
+
+	sysfs_remove_file(&client->dev.kobj, &ap1302_sysfs_attr_write32.attr);
+	sysfs_remove_file(&client->dev.kobj, &ap1302_sysfs_attr_write16.attr);
+	sysfs_remove_file(&client->dev.kobj, &ap1302_sysfs_attr_dump.attr);
+
+	v4l2_async_unregister_subdev(&sensor->sd);
+	mutex_destroy(&sensor->lock);
+	media_entity_cleanup(&sensor->sd.entity);
+	v4l2_ctrl_handler_free(&sensor->ctrls.handler);
+
+	return 0;
+}
+
+static const struct i2c_device_id ap1302_id[] = {
+	{"ap1302", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ap1302_id);
+
+static const struct of_device_id ap1302_dt_ids[] = {
+	{ .compatible = "on,ap1302" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ap1302_dt_ids);
+
+static struct i2c_driver ap1302_i2c_driver = {
+	.driver = {
+		.name  = "ap1302",
+		.of_match_table	= ap1302_dt_ids,
+	},
+	.id_table = ap1302_id,
+	.probe    = ap1302_probe,
+	.remove   = ap1302_remove,
+};
+
+module_i2c_driver(ap1302_i2c_driver);
+
+MODULE_DESCRIPTION("AP1302 MIPI Camera Subdev Driver");
+MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(AP1302_FW_NORMAL);
+MODULE_FIRMWARE(AP1302_FW_TEST);
diff -Naurw ./drivers/media/i2c/Kconfig ../kernel-source/drivers/media/i2c/Kconfig
--- ./drivers/media/i2c/Kconfig	2020-08-15 10:46:21.738948698 +0200
+++ ../kernel-source/drivers/media/i2c/Kconfig	2020-08-15 10:46:49.790400696 +0200
@@ -887,6 +887,18 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called mt9v111.
 
+config VIDEO_AP1302
+	tristate "OnSemi AP1302 ISP + sensor support"
+	depends on OF
+	depends on GPIOLIB && VIDEO_V4L2 && I2C && VIDEO_V4L2_SUBDEV_API
+	depends on MEDIA_CAMERA_SUPPORT
+	select V4L2_FWNODE
+	select VIDEO_ST_MIPID02
+	---help---
+	  This is a Video4Linux2 sensor driver for one OnSemi image
+	  sensor connected to the OnSemi AP1302 ISP through MIPI CSI-2
+	  interface.
+
 config VIDEO_SR030PC30
 	tristate "Siliconfile SR030PC30 sensor support"
 	depends on I2C && VIDEO_V4L2
diff -Naurw ./drivers/media/i2c/Makefile ../kernel-source/drivers/media/i2c/Makefile
--- ./drivers/media/i2c/Makefile	2020-08-15 10:46:21.738948698 +0200
+++ ../kernel-source/drivers/media/i2c/Makefile	2020-08-15 10:46:49.790400696 +0200
@@ -88,6 +88,7 @@
 obj-$(CONFIG_VIDEO_MT9V011) += mt9v011.o
 obj-$(CONFIG_VIDEO_MT9V032) += mt9v032.o
 obj-$(CONFIG_VIDEO_MT9V111) += mt9v111.o
+obj-$(CONFIG_VIDEO_AP1302) += ap1302.o
 obj-$(CONFIG_VIDEO_SR030PC30)	+= sr030pc30.o
 obj-$(CONFIG_VIDEO_NOON010PC30)	+= noon010pc30.o
 obj-$(CONFIG_VIDEO_RJ54N1)	+= rj54n1cb0c.o
